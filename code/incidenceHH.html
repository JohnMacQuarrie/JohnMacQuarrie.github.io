 <!--PREAMBLE--><html><head>





    

    <title>HH code</title>



     <style type="text/css">
    
    #title{
        color:#845B99;
        position: absolute;
        font-size:40px;
        top:23px;
        right:52;
        left: 252px;
        width: 683px;
        vertical-align:bottom;
        height: 55px;
    }
    
    #yetanotherbox{
     left: 227px;
    top: 79px;
    position: absolute;
    }
    
    #backgroundbox{
    border: 0px solid black;

    width: 725px;
    background-color: #D6FF99;
    background-image:url(pictures/bordertemp.GIF);
    background-repeat:no-repeat;
    }
          
    #textbox{
    padding:15px;
    }
    
    #coolmenu{
    border: 0px solid black;
    width: 12em;
    background-color: #FFFF99;
    }
    
    #coolmenu a{
    font: bold 13px Arial, Helvetica, sans-serif;
    padding: 2px;
    padding-left: 4px;
    display: block;
    width: 100%;
    color: #4B543E;
    text-decoration: none;
    border-bottom: 1px dotted #4B543E;
    }
    
    html>body #coolmenu a{
    width: auto;
    }
    
    #coolmenu a:hover{
    background-color: #FFFF99;
    color: #845B99;
    }
    
    #tabledescription{
    width: 100%;
    height: 3em;
    padding: 0px;
    filter:alpha(opacity=0);
    
    color:#4B543E;
    }
    
    .style1 {font-family: "Times New Roman", Times, serif}
    body {
        background-color: #FFFF99;
    }
    </style>
    
    <script type="text/javascript">
    
    // Cool CSS Menu- By JavaScriptKit.com (http://www.javascriptkit.com)
    // For this and over 400+ free scripts, visit JavaScript Kit- http://www.javascriptkit.com/
    // Fading routine based on Dynamic Drive script: http://www.dynamicdrive.com/dynamicindex4/highlightgrad.htm
    // This notice must stay intact for use
    
    var baseopacity=0
    
    function showtext(thetext){
    if (!document.getElementById)
    return
    textcontainerobj=document.getElementById("tabledescription")
    browserdetect=textcontainerobj.filters? "ie" : typeof textcontainerobj.style.MozOpacity=="string"? "mozilla" : ""
    instantset(baseopacity)
    document.getElementById("tabledescription").innerHTML=thetext
    highlighting=setInterval("gradualfade(textcontainerobj)",50)
    }
    
    function hidetext(){
    cleartimer()
    instantset(baseopacity)
    }
    
    function instantset(degree){
    if (browserdetect=="mozilla")
    textcontainerobj.style.MozOpacity=degree/100
    else if (browserdetect=="ie")
    textcontainerobj.filters.alpha.opacity=degree
    else if (document.getElementById && baseopacity==0)
    document.getElementById("tabledescription").innerHTML=""
    }
    
    function cleartimer(){
    if (window.highlighting) clearInterval(highlighting)
    }
    
    function gradualfade(cur2){
    if (browserdetect=="mozilla" && cur2.style.MozOpacity<1)
    cur2.style.MozOpacity=Math.min(parseFloat(cur2.style.MozOpacity)+0.2, 0.99)
    else if (browserdetect=="ie" && cur2.filters.alpha.opacity<100)
    cur2.filters.alpha.opacity+=20
    else if (window.highlighting)
    clearInterval(highlighting)
    }
    
    </script>
            
            <script language="javascript">

            addEvent(window, "load", init);
    
    function init()
    {
    
        form = document.getElementById("form1");
        addEvent(form, "submit", correctSubmitHandler);
    }
    
    function correctSubmitHandler(e)
    {
        //alert("Correct Submit Handler");
        if (e && e.preventDefault)
                e.preventDefault();
        
        form = document.getElementById("form1");
        document.location=form.answer.value+'.html';
        return false;
    }
    
    function doSubmit()
    {
        alert("doSubmit");
        return false;
    }
    
    function addEvent(obj, evType, fn)
    {
        if (obj.addEventListener)
        {
            obj.addEventListener(evType, fn, false);
            return true;
        }
        else if (obj.attachEvent)
        {
            var r = obj.attachEvent("on"+evType, fn);
            return r;
        }
        else
        {
            return false;
        }
    }
    
            </script>	
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$']] },
      TeX: {
      Macros: {
      R: "{\\mathbb R}",
      N: "{\\mathbb N}",
      C: "{\\mathbb C}",
      Z: "{\\mathbb Z}",
      Q: "{\\mathbb Q}",
      mdc: ["{\\mbox{mdc}(#1,#2)}", 2]
      }}});
      </script>
          
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
      </script>

</head> 




    <!--PREAMBLE-->


<body>

    

<div id="title">
  <div align="right">HH for incidence algebras, Sage code</div>
</div>




  </p>
  <div id="tabledescription"></div>
</div>


<div id="yetanotherbox">
<div id="backgroundbox">
<div id="textbox">

<p>
    The following are links relating to code to calculate the Hochschild cohomology groups of the incidence algebra (over a field of specified characteristic) 
    of a finite poset.  
</p>
    
<p>
     <a href="https://johnmacquarrie.github.io/code/iCyclescode.html">This link</a> goes to code for two functions, both of which run in Sage, using functions called from gap, and which can be copy and pasted 
    into a Sage command line.  In both, the input X is a Sage poset object and the input c is either a prime number or 0, specifying 
    the characteristic of the field.
    <ul>
  <li>"iCycles(X,c)", which saves [SOMETHING]</li>
  <li>"iCyclesHH(X,c)", which prints the dimensions of the Hochschild cohomology groups of the incidence algebra of X in characteristic c.</li>
</ul>
      
 </p>

<p>
<a href="https://johnmacquarrie.github.io/code/algcomparison.html">This link</a> goes to code to verify the run-time comparison claims made in Remark 5 of the article "Projective resolutions of simple modules and Hochschild cohomology for 
incidence algebras", where the above algorithm is introduced.  It is Sage code, calling functions both from gap and from Magma (because the algorithm "CompactProjectiveResolution" 
being compared with the iCycles algorithm is, to our knowledge, only available in Magma).  The code can be copy and pasted into a Sage command line.  The recorded time for 
CompactProjectiveResolution includes the time necessary to transfer the necessary data to Magma and retrieve the output, but this is negligible (less than 10 milliseconds) compared 
to the total runtime (on the order of 400 seconds for the posets being considered). 

</p>


 <p>
   


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Formatted Code</title>
  <style>
    body {
      font-family: monospace;
      background-color: #f7f7f7;
    }
    pre {
      background: #ffffff;
      padding: 1em;
      border: 1px solid #ccc;
      overflow-x: auto;
      line-height: 1.4;
    }
  </style>
</head>
<body>

<pre><code>
#GAP FUNCTIONS CALLED IN SAGE    
Indeterminate = libgap.eval("I:=function(x,y) return Indeterminate(x,y); end;");
StringFormatted = libgap.eval("S:=function(x,y,z,w) return StringFormatted(x,y,z,w);end;");
StF = libgap.eval("St:=function(x,y,z) return StringFormatted(x,y,z);end;");
VectorSpace = libgap.eval("V:=function(x,y,z) return VectorSpace(x,y,z);end;");
Cyclesmap = libgap.eval(
"Cyclesmap:=function(Source,Range,cycle)local Im,i,f,D;
 D:=GeneratorsOfVectorSpace(Source);
 Im:=[];
 for i in [1..Length(cycle)] do
   Add(Im, LinearCombination(Basis(Range), cycle[i][1]));
 od;
 f:=LeftModuleGeneralMappingByImages(Source, Range, D, Im);
 return f;
 end;"
);

Z_CycleSpace = libgap.eval(
"Z_CycleSpace:=function(cycles,zlist,Source,f)local K, zSubspace, i, j, aux,
 VerticesOfCycles, CoefficientsOfCycles, T;
 CoefficientsOfCycles:=[];
 if Length(zlist)&gt;0 then
   K:=BasisVectors(Basis((Kernel(RestrictedMapping(f, Subspace(Source,zlist))))));
   for i in [1..Length(K)] do
     Add(CoefficientsOfCycles,Coefficients(Basis(Source), K[i]));
   od;
 fi;
 T:=CoefficientsOfCycles;
 return T;
 end;"
);

BasisComplement = libgap.eval(
"BasisComplement:=function(Aux_Bzminus,Aux_Ciplus, i, OurDomain,OurField)
 local F,Kzminus,t,BC;
 BC:=[];
 F:=OurField^Length(OurDomain);
 if Length(Aux_Bzminus)&gt;0 then
   KZminus:=Subspace(F, Aux_Bzminus);
   for t in [1..Length(Aux_Ciplus[i][1])] do
     if (Aux_Ciplus[i][1][t] in KZminus)=false then
       Add(BC, [Aux_Ciplus[i][1][t], Aux_Ciplus[i][2]]);
       Add(Aux_Bzminus, Aux_Ciplus[i][1][t]);
       KZminus:=Subspace(F, Aux_Bzminus);
     fi;
   od;
 else
   for t in [1..Length(Aux_Ciplus[i][1])] do
     Add(BC, [Aux_Ciplus[i][1][t],Aux_Ciplus[i][2]]);
   od;
 fi;
 return BC;
 end;"
)


def HH(X, c, h, y, xplus):
    # X = extended poset
    # h = x^*
    # c = characteristic of OurField
    # y = y^*
    # xplus = immediate successors of x^*
    
    if c == 0:
        OurField = QQ
    else:
        OurField = GF(c)

    candidates = list(X)

    countHH = 0
    q = 1

    # Building C^1
    
    OurDomain = [Indeterminate(OurField, "x")]  
    iminusCycles = [[1,h]]        
    
    iCycles = []
    for j in xplus:
        iCycles.append([[1], j])

    if len(iCycles) == 0:
        print(" dim HH^i = 0 for all i.")
        q = -1
    elif len(iCycles) == 1:
        print(" dim HH^0 = 1 for i=1.")
        print(" dim HH^i = 0 for i&gt;1.")
        q = -1
    else:
        q += 1

    while q != -1:
        
        OurCodomain = OurDomain
        OurDomain = []

        if q == 2:
            for i in range(len(iCycles)):
                OurDomain.append(
                    Indeterminate(
                        OurField,
                        StF("[{}, {}]", OurCodomain[0], iCycles[i][1])
                    )
                )
        else:
            for i in range(len(iCycles)):
                OurDomain.append(
                    Indeterminate(
                        OurField,
                        StringFormatted("[w^{}_{}, {}]", q-1, i, iCycles[i][1])
                    )
                )

        SourceSpace = VectorSpace(OurField, OurDomain, "basis")
        RangeSpace = VectorSpace(OurField, OurCodomain, "basis")
        f = Cyclesmap(SourceSpace, RangeSpace, iCycles)

        iminusCycles = []
        for i in range(len(iCycles)):
            iminusCycles.append([iCycles[i][0], Integer(iCycles[i][1])])

        iCycles = []
        Aux_Ciplus = []

        for k in candidates:
            zSubspace = []	
            for i in range(len(iminusCycles)):
                if X.is_less_than(iminusCycles[i][1], k):
                    zSubspace.append(OurDomain[i])
            if zSubspace != []:		   
                T = Z_CycleSpace(iminusCycles, zSubspace, SourceSpace, f)
                if T != []:
                    Aux_Ciplus.append([T, k])

        I = list(range(len(Aux_Ciplus)))

        for i in I:
            Aux_Bzminus = set([])
            for j in I:
                if Aux_Ciplus[j][1] in X.lower_covers(Aux_Ciplus[i][1]):
                    Aux_Bzminus.update(Aux_Ciplus[j][0])
            BC = BasisComplement(
                list(Aux_Bzminus),
                Aux_Ciplus,
                i+1,
                OurDomain,
                OurField
            )
            if len(BC) != 0: 
                [iCycles.append(a) for a in BC]
			
        if len(iCycles) == 0:
            print(f" dim HH^i = 0 for i&gt;", q-3)
            q = -1
        else:
            for i in range(len(iCycles)):
                if iCycles[i][1] == y:
                    countHH += 1

            if q == 2:
                print(f" dim HH^", q-2, " = ", countHH + 1)
            else:
                print(f" dim HH^", q-2, " = ", countHH)
            
            q += 1
            countHH = 0
</code></pre>

</body>
</html>

</p>


</div>
</div>

<div>&nbsp;</div>
</div>

</body>


</html>













